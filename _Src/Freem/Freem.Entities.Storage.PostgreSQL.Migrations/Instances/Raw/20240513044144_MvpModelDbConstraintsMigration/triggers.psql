-- Begin check Categories Tags
-- Begin declaration

create or replace function ${EnvironmentNames.Schema}.check_categories_tags_user_ids()
returns trigger
language PLPGSQL
as $$
declare 
	category_user_id text;
	tag_user_id text;
begin
	select user_id from ${EnvironmentNames.Schema}.categories where id = new.category_id into category_user_id;
	select user_id from ${EnvironmentNames.Schema}.tags where id = new.tag_id into tag_user_id;
	
	if category_user_id <> tag_user_id then
	    call ${EnvironmentNames.Schema}.throw_exception(
	        '${TriggerErrorCodes.CategoriesTagsDifferentUserIds}', 
	        'category.user_id must be equals tags.user_id',
	        array[('${TriggerErrorParameters.CategoryIdTriggerErrorParameterName}', new.category_id), ('${TriggerErrorParameters.TagIdTriggerErrorParameterName}', new.tag_id)]::${EnvironmentNames.Schema}.exception_parameter[]);
	end if;

	return new;
end;
$$;

create constraint trigger check_categories_tags_user_ids_trigger
	after insert or update
	on ${EnvironmentNames.Schema}.categories_tags
	for each row
	execute procedure ${EnvironmentNames.Schema}.check_categories_tags_user_ids();

create or replace procedure ${EnvironmentNames.Schema}.check_category_tags_count(id text)
language PLPGSQL
as $$
declare
	tags_count int;
begin
	select count(*) from ${EnvironmentNames.Schema}.categories_tags where category_id = id into tags_count;

	if tags_count < ${Limits.MinRelatedTagsCount} or tags_count > ${Limits.MaxRelatedTagsCount} then
	    call ${EnvironmentNames.Schema}.throw_exception(
	        '${TriggerErrorCodes.CategoriesTagsInvalidCount}', 
        	'categories must have tags in range [${Limits.MinRelatedTagsCount}, ${Limits.MaxRelatedTagsCount}]',
        	array[('${TriggerErrorParameters.CategoryIdTriggerErrorParameterName}', id), ('${TriggerErrorParameters.ActualCountTriggerErrorParameterName}', tags_count)]::${EnvironmentNames.Schema}.exception_parameter[]);
	end if;
end;
$$;

create or replace function ${EnvironmentNames.Schema}.check_categories_tags_count_on_insert_or_update_relation()
returns trigger
language PLPGSQL
as $$
begin
	call ${EnvironmentNames.Schema}.check_category_tags_count(new.category_id);
	return new;
end;
$$;

create constraint trigger check_categories_tags_count_trigger
	after insert or update
	on ${EnvironmentNames.Schema}.categories_tags
	deferrable initially deferred
	for each row
	execute procedure ${EnvironmentNames.Schema}.check_categories_tags_count_on_insert_or_update_relation();

-- End declaration
-- Begin dropping

drop trigger if exists check_categories_tags_user_ids_trigger on ${EnvironmentNames.Schema}.categories_tags;
drop function if exists ${EnvironmentNames.Schema}.check_categories_tags_user_ids;

drop trigger if exists check_categories_tags_count_trigger on ${EnvironmentNames.Schema}.categories_tags;
drop function if exists ${EnvironmentNames.Schema}.check_categories_tags_count_on_insert_or_insert_relation;
drop procedure if exists ${EnvironmentNames.Schema}.check_category_tags_count;

-- End dropping
-- End check Categories Tags



-- Begin check Records Tags
-- Begin declaration

create or replace function ${EnvironmentNames.Schema}.check_records_tags_user_ids()
returns trigger
language PLPGSQL
as $$
declare
	record_user_id text;
	tag_user_id text;
begin
	select user_id from ${EnvironmentNames.Schema}.records where id = new.record_id into record_user_id;
	select user_id from ${EnvironmentNames.Schema}.tags where id = new.tag_id into tag_user_id;

	if record_user_id <> tag_user_id then
	    call ${EnvironmentNames.Schema}.throw_exception(
	        '${TriggerErrorCodes.RecordsTagsDifferentUserIds}', 
        	'records.user_id must be equals tags.user_id',
        	array[('${TriggerErrorParameters.RecordIdTriggerErrorParameterName}', new.record_id), ('${TriggerErrorParameters.TagIdTriggerErrorParameterName}', new.tag_id)]::${EnvironmentNames.Schema}.exception_parameter[]);
	end if;

	return new;
end;
$$;

create constraint trigger check_records_tags_user_ids_trigger
	after insert or update
	on ${EnvironmentNames.Schema}.records_tags
	for each row
	execute procedure ${EnvironmentNames.Schema}.check_records_tags_user_ids();

create or replace procedure ${EnvironmentNames.Schema}.check_record_tags_count(id text)
language PLPGSQL
as $$
declare
	tags_count int;
begin
	select count(*) from ${EnvironmentNames.Schema}.records_tags where record_id = id into tags_count;

	if tags_count < ${Limits.MinRelatedTagsCount} or tags_count > ${Limits.MaxRelatedTagsCount} then
	    call ${EnvironmentNames.Schema}.throw_exception(
    	    '${TriggerErrorCodes.RecordsTagsInvalidCount}', 
            'records must have tags in range [${Limits.MinRelatedTagsCount}, ${Limits.MaxRelatedTagsCount}]',
            array[('${TriggerErrorParameters.RecordIdTriggerErrorParameterName}', id), ('${TriggerErrorParameters.ActualCountTriggerErrorParameterName}', tags_count)]::${EnvironmentNames.Schema}.exception_parameter[]);
	end if;
end;
$$;

create or replace function ${EnvironmentNames.Schema}.check_records_tags_count_on_insert_or_update_relation()
returns trigger
language PLPGSQL
as $$
begin
	call ${EnvironmentNames.Schema}.check_record_tags_count(new.record_id);
	return new;
end;
$$;

create constraint trigger check_records_tags_count_trigger
	after insert or update
	on ${EnvironmentNames.Schema}.records_tags
	deferrable initially deferred
	for each row
	execute procedure ${EnvironmentNames.Schema}.check_records_tags_count_on_insert_or_update_relation();

-- End declaration
-- Begin dropping

drop trigger if exists check_records_tags_user_ids_trigger on ${EnvironmentNames.Schema}.records_tags;
drop function if exists ${EnvironmentNames.Schema}.check_records_tags_user_ids;

drop trigger if exists check_records_tags_count_trigger on ${EnvironmentNames.Schema}.records_tags;
drop function if exists ${EnvironmentNames.Schema}.check_records_tags_count_on_insert_or_update_relation;
drop procedure if exists ${EnvironmentNames.Schema}.check_record_tags_count;

-- End dropping
-- End check Records Tags



-- Begin check RunningRecords Tags
-- Begin declaration

create or replace function ${EnvironmentNames.Schema}.check_running_records_tags_user_ids()
returns trigger
language PLPGSQL
as $$
declare
	tag_user_id text;
begin
	select user_id from ${EnvironmentNames.Schema}.tags where id = new.tag_id into tag_user_id;

	if new.user_id <> tag_user_id then
		call ${EnvironmentNames.Schema}.throw_exception(
            '${TriggerErrorCodes.RunningRecordsTagsDifferentUserIds}', 
            'running_records.user_id must be equals tags.user_id',
            array[('${TriggerErrorParameters.UserIdTriggerErrorParameterName}', new.user_id), ('${TriggerErrorParameters.TagIdTriggerErrorParameterName}', new.tag_id)]::${EnvironmentNames.Schema}.exception_parameter[]);
	end if;

	return new;
end;
$$;

create constraint trigger check_running_records_tags_user_ids_trigger
	after insert or update
	on ${EnvironmentNames.Schema}.running_records_tags
	for each row
	execute procedure ${EnvironmentNames.Schema}.check_running_records_tags_user_ids();

create or replace procedure ${EnvironmentNames.Schema}.check_running_records_tags_count(id text)
language PLPGSQL
as $$
declare
	tags_count int;
begin
	select count(*) from ${EnvironmentNames.Schema}.running_records where user_id = id into tags_count;

	if tags_count < ${Limits.MinRelatedTagsCount} or tags_count > ${Limits.MaxRelatedTagsCount} then
	    call ${EnvironmentNames.Schema}.throw_exception(
	        '${TriggerErrorCodes.RunningRecordsTagsInvalidCount}', 
            'running_records must have tags in range [${Limits.MinRelatedTagsCount}, ${Limits.MaxRelatedTagsCount}]',
            array[('${TriggerErrorParameters.UserIdTriggerErrorParameterName}', id), ('${TriggerErrorParameters.ActualCountTriggerErrorParameterName}', tags_count)]::${EnvironmentNames.Schema}.exception_parameter[]);
	end if;
end;
$$;

create or replace function ${EnvironmentNames.Schema}.check_running_records_tags_count_on_insert_or_update_relation()
returns trigger
language PLPGSQL
as $$
begin
	call ${EnvironmentNames.Schema}.check_running_records_tags_count(new.user_id);
	return new;
end;
$$;

create constraint trigger check_running_records_tags_count_trigger
	after insert or update 
	on ${EnvironmentNames.Schema}.running_records_tags
	deferrable initially deferred
	for each row
	execute procedure ${EnvironmentNames.Schema}.check_running_records_tags_count_on_insert_or_update_relation();

-- End declaration
-- Begin dropping

drop trigger if exists check_running_records_tags_user_ids_trigger on ${EnvironmentNames.Schema}.running_records_tags;
drop function if exists ${EnvironmentNames.Schema}.check_running_records_tags_user_ids;

drop trigger if exists check_running_records_tags_count_trigger on ${EnvironmentNames.Schema}.running_records_tags;
drop function if exists ${EnvironmentNames.Schema}.check_running_records_tags_count_on_insert_or_update_relation;
drop procedure if exists ${EnvironmentNames.Schema}.check_running_records_tags_count;

-- End dropping
-- End check RunningRecords Tags



-- Begin check Records Categories
-- Begin declaration

create or replace function ${EnvironmentNames.Schema}.check_records_categories_user_ids()
returns trigger
language PLPGSQL
as $$
declare
	record_user_id text;
	category_user_id text;
begin
	select user_id from ${EnvironmentNames.Schema}.records where id = new.record_id into record_user_id;
	select user_id from ${EnvironmentNames.Schema}.categories where id = new.category_id into category_user_id;

	if record_user_id <> category_user_id then
	    call ${EnvironmentNames.Schema}.throw_exception(
	        '${TriggerErrorCodes.RecordsCategoriesDifferentUserIds}', 
        	'records.user_id must be equals categories.user_id',
        	array[('${TriggerErrorParameters.RecordIdTriggerErrorParameterName}', new.record_id), ('${TriggerErrorParameters.CategoryIdTriggerErrorParameterName}', new.category_id)]::${EnvironmentNames.Schema}.exception_parameter[]);
	end if;

	return new;
end;
$$;

create constraint trigger check_records_categories_user_ids_trigger
	after insert or update
	on ${EnvironmentNames.Schema}.records_categories
	for each row
	execute procedure ${EnvironmentNames.Schema}.check_records_categories_user_ids();

create or replace procedure ${EnvironmentNames.Schema}.check_record_categories_count(id text)
language PLPGSQL
as $$
declare 
	categories_count int;
begin
	select count(*) from ${EnvironmentNames.Schema}.records_categories where record_id = id into categories_count;

	if categories_count < ${Limits.MinRelatedCategoriesCount} or categories_count > ${Limits.MaxRelatedCategoriesCount} then
	    call ${EnvironmentNames.Schema}.throw_exception(
	        '${TriggerErrorCodes.RecordsCategoriesInvalidCount}', 
            'running_records must have categories in range [${Limits.MinRelatedCategoriesCount}, ${Limits.MaxRelatedCategoriesCount}]',
            array[('${TriggerErrorParameters.RecordIdTriggerErrorParameterName}', id), ('${TriggerErrorParameters.ActualCountTriggerErrorParameterName}', categories_count)]::${EnvironmentNames.Schema}.exception_parameter[]);
	end if;
end;
$$;

create or replace function ${EnvironmentNames.Schema}.check_record_categories_count_on_insert_record()
returns trigger
language PLPGSQL
as $$
begin 
	call ${EnvironmentNames.Schema}.check_record_categories_count(new.id);
	return new;
end;
$$;

create or replace function ${EnvironmentNames.Schema}.check_record_categories_count_on_insert_or_update_relation()
returns trigger
language PLPGSQL
as $$
begin 
	call ${EnvironmentNames.Schema}.check_record_categories_count(new.record_id);
	return new;
end;
$$;

create or replace function ${EnvironmentNames.Schema}.check_record_categories_count_on_delete_relation()
returns trigger
language PLPGSQL
as $$
begin
	call ${EnvironmentNames.Schema}.check_record_categories_count(old.record_id);
	return old;
end;
$$;

create constraint trigger check_record_categories_count_trigger
	after insert
	on ${EnvironmentNames.Schema}.records
	deferrable initially deferred
	for each row
	execute procedure ${EnvironmentNames.Schema}.check_record_categories_count_on_insert_record();

create constraint trigger check_record_categories_count_delete_trigger
	after delete
	on ${EnvironmentNames.Schema}.records_categories
	deferrable initially deferred
	for each row
	execute procedure ${EnvironmentNames.Schema}.check_record_categories_count_on_delete_relation();

create constraint trigger check_record_categories_count_insert_or_update_trigger
	after insert or update
	on ${EnvironmentNames.Schema}.records_categories
	deferrable initially deferred
	for each row
	execute procedure ${EnvironmentNames.Schema}.check_record_categories_count_on_insert_or_update_relation();

-- End declaration
-- Begin dropping

drop trigger if exists check_records_categories_user_ids_trigger on ${EnvironmentNames.Schema}.records_categories;
drop function if exists ${EnvironmentNames.Schema}.check_records_categories_user_ids;
drop trigger if exists check_record_categories_count_trigger on ${EnvironmentNames.Schema}.records;
drop function if exists ${EnvironmentNames.Schema}.check_record_categories_count_on_insert_record;
drop trigger if exists check_record_categories_count_delete_trigger on ${EnvironmentNames.Schema}.records_categories;
drop trigger if exists check_record_categories_count_insert_or_update_trigger on ${EnvironmentNames.Schema}.records_categories;
drop function if exists ${EnvironmentNames.Schema}.check_record_categories_count_on_delete_relation;
drop function if exists ${EnvironmentNames.Schema}.check_record_categories_count_on_insert_or_update_relation;
drop procedure if exists ${EnvironmentNames.Schema}.check_record_categories_count;

-- End dropping
-- End check Records Categories



-- Begin check RunningRecords Categories
-- Begin declaration

create or replace function ${EnvironmentNames.Schema}.check_running_records_categories_user_ids()
returns trigger
language PLPGSQL
as $$
declare
	category_user_id text;
begin
	select user_id from ${EnvironmentNames.Schema}.categories where id = new.category_id into category_user_id;

	if new.user_id <> category_user_id then
	    call ${EnvironmentNames.Schema}.throw_exception(
	        '${TriggerErrorCodes.RunningRecordsCategoriesDifferentUserIds}', 
        	'running_records.user_id must be equals categories.user_id',
        	array[('${TriggerErrorParameters.UserIdTriggerErrorParameterName}', new.user_id), ('${TriggerErrorParameters.CategoryIdTriggerErrorParameterName}', new.category_id)]::${EnvironmentNames.Schema}.exception_parameter[]);
	end if;

	return new;
end;
$$;

create constraint trigger check_running_records_categories_user_ids_trigger
	after insert or update
	on ${EnvironmentNames.Schema}.running_records_categories
	for each row
	execute procedure ${EnvironmentNames.Schema}.check_running_records_categories_user_ids();

create or replace procedure ${EnvironmentNames.Schema}.check_running_record_categories_count(id text)
language PLPGSQL
as $$
declare
	categories_count int;
begin
	select count(*) from ${EnvironmentNames.Schema}.running_records_categories where user_id = id into categories_count;

	if categories_count < ${Limits.MinRelatedCategoriesCount} or categories_count > ${Limits.MaxRelatedCategoriesCount} then
	    call ${EnvironmentNames.Schema}.throw_exception(
	        '${TriggerErrorCodes.RunningRecordsCategoriesInvalidCount}', 
            'running_records must have categories in range [${Limits.MinRelatedCategoriesCount}, ${Limits.MaxRelatedCategoriesCount}]',
            array[('${TriggerErrorParameters.UserIdTriggerErrorParameterName}', id), ('${TriggerErrorParameters.ActualCountTriggerErrorParameterName}', categories_count)]::${EnvironmentNames.Schema}.exception_parameter[]);
	end if;
end;
$$;

create or replace function ${EnvironmentNames.Schema}.check_running_records_categories_count_on_insert_running_record()
returns trigger
language PLPGSQL
as $$
begin
	call ${EnvironmentNames.Schema}.check_running_record_categories_count(new.user_id);
	return new;
end;
$$;

create or replace function ${EnvironmentNames.Schema}.check_running_records_categories_count_on_delete_relation()
returns trigger
language PLPGSQL
as $$
begin
	call ${EnvironmentNames.Schema}.check_running_record_categories_count(old.user_id);
	return old;
end;
$$;

create or replace function ${EnvironmentNames.Schema}.check_running_records_categories_count_on_iu_relation()
returns trigger
language PLPGSQL
as $$
begin
	call ${EnvironmentNames.Schema}.check_running_record_categories_count(new.user_id);
	return new;
end;
$$;

create constraint trigger check_running_records_categories_count_trigger
	after insert
	on ${EnvironmentNames.Schema}.running_records
	deferrable initially deferred
	for each row
	execute procedure ${EnvironmentNames.Schema}.check_running_records_categories_count_on_insert_running_record();

create constraint trigger check_running_records_categories_count_delete_trigger
	after delete
	on ${EnvironmentNames.Schema}.running_records_categories
	deferrable initially deferred
	for each row
	execute procedure ${EnvironmentNames.Schema}.check_running_records_categories_count_on_delete_relation();

create constraint trigger check_running_records_categories_count_insert_or_update_trigger
	after insert or update
	on ${EnvironmentNames.Schema}.running_records_categories
	deferrable initially deferred
	for each row
	execute procedure ${EnvironmentNames.Schema}.check_running_records_categories_count_on_iu_relation();

-- End declaration
-- Begin dropping

drop trigger if exists check_running_records_categories_user_ids_trigger on ${EnvironmentNames.Schema}.running_records_categories;
drop function if exists ${EnvironmentNames.Schema}.check_running_records_categories_user_ids;

drop trigger if exists check_running_records_categories_count_trigger on ${EnvironmentNames.Schema}.running_records;
drop trigger if exists check_running_records_categories_count_delete_trigger on ${EnvironmentNames.Schema}.running_records_categories;
drop trigger if exists check_running_records_categories_count_insert_or_update_trigger on ${EnvironmentNames.Schema}.running_records_categories;
drop function if exists ${EnvironmentNames.Schema}.check_running_records_categories_count_on_insert_running_record;
drop function if exists ${EnvironmentNames.Schema}.check_running_records_categories_count_on_delete_relation;
drop function if exists ${EnvironmentNames.Schema}.check_running_records_categories_count_on_iu_relation;
drop procedure if exists ${EnvironmentNames.Schema}.check_running_record_categories_count;

-- End dropping
-- End check RunningRecords Categories